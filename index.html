<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Square Packing</title>

<style>
body {
  margin: 0;
  background: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  color: white;
  font-family: sans-serif;
}

#container { position: relative; }

#ui {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 10;
  font-size: 14px;
  user-select: none;
  background: rgba(0,0,0,0.5);
  padding: 12px;
  border-radius: 8px;
  width: 220px;
}

input[type="range"],
input[type="number"] { width: 140px; }

.value { float: right; }
</style>
</head>
<body>

<div id="container"></div>

<div id="ui">
  Boxes:
  <input id="count" type="number" value="5" min="1" max="200"><br><br>

  Box size (px):
  <input id="sizeInput" type="number" value="200">
  <div id="sizeLabel"></div><br>

  Friction <span class="value" id="frictionVal"></span><br>
  <input id="friction" type="range" min="-1" max="1" step="0.01" value="0"><br>

  Air friction <span class="value" id="frictionAirVal"></span><br>
  <input id="frictionAir" type="range" min="-0.1" max="0.1" step="0.001" value="0"><br>

  Restitution <span class="value" id="restitutionVal"></span><br>
  <input id="restitution" type="range" min="-2" max="2" step="0.01" value="1"><br>

  Density <span class="value" id="densityVal"></span><br>
  <input id="density" type="range" min="-1" max="1" step="0.0005" value="0.002"><br><br>

  <label><input type="checkbox" id="showVelocity"> Show velocity</label><br>
  <label><input type="checkbox" id="drawPath"> Draw path</label><br><br>

  <button onclick="reset()">Reset</button><br><br>
  <div id="momentum">Total momentum: 0</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
<script>
const {
  Engine, Render, Runner,
  Bodies, Composite, Body,
  Mouse, MouseConstraint, Events
} = Matter;

const FRAME_SIZE = 600;
let WALL_THICKNESS = 2000000;
const VELOCITY_SCALE = 15;
let PATH_LIFE = 2000;

let engine, world, render, runner;
let boxes = [];
let currentBoxSize = 200;
let paths = new Map();

const ui = {
  count,
  size: sizeInput,
  friction,
  frictionAir,
  restitution,
  density,
  showVelocity,
  drawPath
};

const labels = {
  friction: frictionVal,
  frictionAir: frictionAirVal,
  restitution: restitutionVal,
  density: densityVal,
  size: sizeLabel
};

function randColor() {
  return `hsl(${Math.random()*360},80%,60%)`;
}

function updateSizeLabel() {
  const px = +ui.size.value;
  labels.size.innerText = `${px}px (${(px/FRAME_SIZE*100).toFixed(1)}%)`;
}

function updateSizeLive() {
  const newSize = +ui.size.value;
  const scale = newSize / currentBoxSize;
  boxes.forEach(b => Body.scale(b, scale, scale));
  currentBoxSize = newSize;
  updateSizeLabel();
}

function applyPhysicsLive() {
  boxes.forEach(b => {
    b.friction = +ui.friction.value;
    b.frictionAir = +ui.frictionAir.value;
    b.restitution = +ui.restitution.value;
    Body.setDensity(b, +ui.density.value);
  });

  labels.friction.innerText = ui.friction.value;
  labels.frictionAir.innerText = ui.frictionAir.value;
  labels.restitution.innerText = ui.restitution.value;
  labels.density.innerText = ui.density.value;
}

Object.values(ui).forEach(el => {
  if (el.type !== "checkbox") el.addEventListener("input", applyPhysicsLive);
});
ui.size.addEventListener("input", updateSizeLive);

function reset() {
  if (engine) {
    Render.stop(render);
    Runner.stop(runner);
    Composite.clear(world);
    render.canvas.remove();
  }

  paths.clear();

  engine = Engine.create();
  engine.gravity.x = engine.gravity.y = 0;
  world = engine.world;

  render = Render.create({
    element: container,
    engine,
    options: {
      width: FRAME_SIZE,
      height: FRAME_SIZE,
      wireframes: false,
      background: "#111"
    }
  });

  runner = Runner.create();

  const c = FRAME_SIZE / 2;
  Composite.add(world, [
    Bodies.rectangle(c, -WALL_THICKNESS/2, FRAME_SIZE, WALL_THICKNESS, { isStatic:true }),
    Bodies.rectangle(c, FRAME_SIZE+WALL_THICKNESS/2, FRAME_SIZE, WALL_THICKNESS, { isStatic:true }),
    Bodies.rectangle(-WALL_THICKNESS/2, c, WALL_THICKNESS, FRAME_SIZE, { isStatic:true }),
    Bodies.rectangle(FRAME_SIZE+WALL_THICKNESS/2, c, WALL_THICKNESS, FRAME_SIZE, { isStatic:true })
  ]);

  boxes = [];
  currentBoxSize = +ui.size.value;

  for (let i=0;i<+ui.count.value;i++) {
    const color = randColor();
    const b = Bodies.rectangle(
      Math.random()*FRAME_SIZE,
      Math.random()*FRAME_SIZE,
      currentBoxSize,
      currentBoxSize,
      { render:{ fillStyle: color } }
    );
    b.pathColor = color;

    Body.setVelocity(b,{
      x:(Math.random()-0.5)*5,
      y:(Math.random()-0.5)*5
    });

    boxes.push(b);
    paths.set(b, []);
  }

  Composite.add(world, boxes);
  applyPhysicsLive();
  updateSizeLabel();

  const mouse = Mouse.create(render.canvas);
  Composite.add(world, MouseConstraint.create(engine,{
    mouse,
    constraint:{ stiffness:0.2, render:{visible:false} }
  }));
  render.mouse = mouse;

  Events.on(engine,"afterUpdate",()=>{
    if (!ui.drawPath.checked) return;
    const now = Date.now();

    boxes.forEach(b=>{
      const arr = paths.get(b);
      arr.push({ x:b.position.x, y:b.position.y, t:now });

      while (arr.length && now - arr[0].t > PATH_LIFE) {
        arr.shift();
      }
    });
  });

  Events.on(render,"afterRender",()=>{
    const ctx = render.context;
    const now = Date.now();

    if (ui.drawPath.checked) {
      paths.forEach((arr,b)=>{
        if (arr.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = b.pathColor;
        ctx.lineWidth = 2;

        arr.forEach((p,i)=>{
          ctx.globalAlpha = Math.max(0,1-(now-p.t)/PATH_LIFE);
          if (i===0) ctx.moveTo(p.x,p.y);
          else ctx.lineTo(p.x,p.y);
        });

        ctx.stroke();
      });
      ctx.globalAlpha = 1;
    }

    if (ui.showVelocity.checked) {
      ctx.strokeStyle="#fff";
      ctx.lineWidth=2;
      boxes.forEach(b=>{
        ctx.beginPath();
        ctx.moveTo(b.position.x,b.position.y);
        ctx.lineTo(
          b.position.x+b.velocity.x*VELOCITY_SCALE,
          b.position.y+b.velocity.y*VELOCITY_SCALE
        );
        ctx.stroke();
      });
    }
  });

  Render.run(render);
  Runner.run(runner, engine);
}

function updateMomentum() {
  let px=0,py=0;
  boxes.forEach(b=>{
    px+=b.mass*b.velocity.x;
    py+=b.mass*b.velocity.y;
  });
  momentum.innerText="Total momentum: "+Math.hypot(px,py).toFixed(4);
  requestAnimationFrame(updateMomentum);
}

reset();
updateMomentum();
</script>
</body>
</html>
